#!/usr/bin/env python3

# pylint: disable=invalid-name, ungrouped-imports, too-many-lines, missing-docstring, line-too-long


# #############################################################################
# performance / time measurements
# #############################################################################


import time

_time_funcs = (time.time, time.perf_counter, time.process_time)

def _get_times_now():
    return [fn() for fn in _time_funcs]

_time_starts = _get_times_now()

def _log_elapsed_time(since=None):
    if since is None:
        since = _time_starts
    elapsed_times = [fn() - t_start for fn, t_start in zip(_time_funcs, since)]
    logging.debug("Elapsed time: %s", elapsed_times)

def _measure_startup_time(loop):

    def remove_idle_callback(loop, _user_data):
        logging.debug("Urwid has entered idle state")
        _log_elapsed_time()
        loop.event_loop.remove_enter_idle(idle_callback_handle)
        #raise urwid.ExitMainLoop  # testing the real time with `time scli`

    def idle_callback():
        #loop.event_loop.remove_enter_idle(idle_callback_handle)  # TODO: comment: this does not work, so need to resort to scheduling an 'alarm'
        loop.set_alarm_in(0, remove_idle_callback)

    idle_callback_handle = loop.event_loop.enter_idle(idle_callback)


import os
import re
import sys
import json
import subprocess
import tempfile
import atexit
import argparse
import logging
import errno
import textwrap
import bisect
import shlex
from subprocess import PIPE, Popen
from datetime import datetime
import base64
import collections
import pprint  # Debug

import urwid

try:
    from urwid_readline import ReadlineEdit

    Edit = ReadlineEdit
except ImportError:
    Edit = urwid.Edit




# #############################################################################
# constants
# #############################################################################

DATA_FOLDER = os.getenv('XDG_DATA_HOME', os.path.expanduser('~/.local/share'))
CFG_FOLDER = os.getenv('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))

SIGNALCLI_LEGACY_FOLDER = os.path.join(CFG_FOLDER, 'signal')
SIGNALCLI_LEGACY_DATA_FOLDER = os.path.join(SIGNALCLI_LEGACY_FOLDER, 'data')
SIGNALCLI_LEGACY_ATTACHMENT_FOLDER = os.path.join(SIGNALCLI_LEGACY_FOLDER, 'attachments')

SIGNALCLI_FOLDER = os.path.join(DATA_FOLDER, 'signal-cli')
SIGNALCLI_DATA_FOLDER = os.path.join(SIGNALCLI_FOLDER, 'data')
SIGNALCLI_ATTACHMENT_FOLDER = os.path.join(SIGNALCLI_FOLDER, 'attachments')

SCLI_DATA_FOLDER = os.path.join(DATA_FOLDER, 'scli')
SCLI_HISTORY_FILE = os.path.join(SCLI_DATA_FOLDER, 'history')
SCLI_CFG_FILE = os.path.join(CFG_FOLDER, 'sclirc')
SCLI_LOG_FILE = os.path.join(SCLI_DATA_FOLDER, 'log')

# #############################################################################
# coloring stuff
# #############################################################################

# TODO: make costumizable

PALETTE = [
    ('normal', '', ''),
    ('box_normal', '', ''),
    ('box_focused', 'dark blue', ''),
    ('bold', 'bold', ''),
    ('italic', 'italics', ''),
    ('strikethrough', 'strikethrough', ''),
    ('bolditalic', 'italics,bold', ''),
    ('reversed', 'standout', ''),
    ('reversed_italic', 'standout,italics', ''),
    ('reversed_strikethrough', 'standout,strikethrough', ''),
]

LIST_FOCUS_MAP = {
    None: 'reversed',
    'normal': 'reversed',
    'bold': 'reversed',
    'italic': 'reversed_italic',
    'bolditalic': 'reversed',
    'strikethrough': 'reversed_strikethrough',
}

FORMAT_MAP = {'_': 'italic', '*': 'bold', '~': 'strikethrough'}


def ibtxt(txt):
    return ('bolditalic', txt)


def ntxt(txt):
    return ('normal', txt)


def btxt(txt):
    return ('bold', txt)


def itxt(txt):
    return ('italic', txt)


def to_txt(txt):
    if isinstance(txt, str):
        return txt
    elif isinstance(txt, tuple):
        return txt[1]
    else:
        return ''.join([to_txt(t) for t in txt])


# #############################################################################
# utility
# #############################################################################


def noop(*args, **kwargs):
    pass

def has_key(key, x):
    if x:
        return key in x
    return False


def get_nested(dct, *keys, default=None):
    for key in keys:
        try:
            dct = dct[key]
        except (KeyError, TypeError, IndexError):
            return default
    return dct


def get_urls(txt):
    return re.findall(r'(https?://[^\s]+)', txt)


def mk_call(cmd, rmap=None, disown=False, use_pipe=True):
    if not rmap:
        rmap = {}

    for key, val in rmap.items():
        cmd = cmd.replace(key, val)

    if disown:
        with open(os.devnull, 'w') as f:
            subprocess.Popen(cmd, shell=True, stdout=f, stderr=f, preexec_fn=os.setpgrp)
    else:
        if use_pipe:
            pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        else:
            pipe = subprocess.Popen(cmd, shell=True)

        out, err = pipe.communicate()
        logging.info('mk_call:%s', cmd)
        try:
            if pipe.returncode == 0:
                logging.info('mk_call:exit_0:%s', out.decode('utf-8'))
            else:
                logging.critical('mk_call:exit_%d:%s', pipe.returncode, err.decode('utf-8'))
        except AttributeError:
            pass

        return out


PHONE_NUM_REGEX = re.compile('^\\+[1-9][0-9]{6,14}$')
# https://github.com/signalapp/libsignal-service-java/blob/master/java/src/main/java/org/whispersystems/signalservice/api/util/PhoneNumberFormatter.java
def is_number(number):
    return bool(PHONE_NUM_REGEX.match(number))


def is_path(path):
    return path.startswith(("/", "~/", "./"))


PATH_RE = re.compile(
    r"""
        # Matches a path-like string, with whitespaces escaped or with the whole path in quotes.
        (
            (
                \\\ |           # escaped whitespace OR ..
                [^'" ]          # .. not a quote or space
            )+
        )                       # Path with escaped whitespace ..
        |                       # .. OR ..
        (                       # .. path in quotes.
            (?P<quote>['"])     # a quote char; name the capture
            .+?                 # anything, non-greedily
            (?P=quote)          # matching quote
        )
        """,
    re.VERBOSE,
)
def split_path(string):
    string = string.strip()
    if not string:
        return ['', '']
    re_match = PATH_RE.match(string)
    if not re_match:
        return ['', string]
    path = re_match.group()
    if re_match.group(1):  # unquoted path
        path = path.replace(r'\ ', ' ')
    else:  # path in quotes
        path = path.strip('\'"')
    rest = string[re_match.end() :].strip()
    return [path, rest] if rest else [path]


class ObservableConfig:
    signals = ['changed']

    def __init__(self, cfg_obj):
        self._cfg_obj = cfg_obj

    def __getattr__(self, name):
        return getattr(self._cfg_obj, name)

    def __setattr__(self, name, value):
        if name != '_cfg_obj' and hasattr(self._cfg_obj, name):
            setattr(self._cfg_obj, name, value)
            urwid.emit_signal(self, 'changed', name, value)
        else:
            super().__setattr__(name, value)


urwid.register_signal(ObservableConfig, ObservableConfig.signals)




# #############################################################################
# signal utility
# #############################################################################

def hash_contact(x):
    h = get_contact_id(x)
    if h is None:
        logging.critical('hash_contact:No number or groupId')
    return h


def get_contact_name(x):
    if not x:
        logging.critical('get_contact_name:empty sender')
        return "NULL"

    if isinstance(x, str):
        return x

    name = x.get('name')
    if name and not name.isspace():
        return name

    return get_contact_number(x)


def get_contact_number(x):
    if not x:
        logging.critical('get_contact_number:empty sender')
        return "NULL"

    number = x.get('number')
    if number:
        return number

    return "NULL"


def get_contact_id(contact):
    if not contact:
        logging.critical('get_contact_number:empty sender')
        return "NULL"

    return contact.get('number') or contact.get('groupId')


def get_contact_color(x):
    color = x.get('color')
    if color or color.strip(' ') != '':
        return color

    return 'white'


def get_group_members(group, exclude=None):
    ret = set()
    if exclude is None:
        exclude = []
    members = group['members']
    for m in members:
        try:
            phone_num = m['number']
        except TypeError:
            phone_num = m
        if phone_num not in exclude:
            ret.add(phone_num)
    return ret


def is_contact_group(contact):
    return has_key('groupId', contact)


def is_envelope_outgoing(envelope):
    return 'target' in envelope or get_nested(envelope, 'syncMessage', 'sentMessage') is not None


def is_envelope_group_message(envelope):
    return (
        get_nested(envelope, 'dataMessage', 'groupInfo') is not None
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'groupInfo') is not None
        or ('target' in envelope and not is_number(envelope['target']))
    )


def get_envelope_msg(envelope):
    # If the `message` field is absent from the envelope: return None. If it is present but contains no text (since signal-cli v0.6.8, this is represented as `'message': null`): return ''. Otherwise: return the `message` field's value.
    for msg in (
        get_nested(envelope, 'dataMessage', 'message', default=0),
        get_nested(envelope, 'syncMessage', 'sentMessage', 'message', default=0),
    ):
        if msg is None:
            return ''
        elif msg != 0:
            return msg
    return None


def get_envelope_time(envelope):
    return (
        get_nested(envelope, 'dataMessage', 'timestamp')
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'timestamp')
        or envelope['timestamp']
    )


def get_envelope_contact_id(envelope):
    return (
        envelope.get('target')
        or get_nested(envelope, 'dataMessage', 'groupInfo', 'groupId')
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'groupInfo', 'groupId')
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'destination')
        or envelope['source']
    )


def get_envelope_attachments(envelope):
    return (
        get_nested(envelope, 'dataMessage', 'attachments')
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'attachments')
        or []
    )


def get_attachment_name(attachment):
    if isinstance(attachment, dict):
        filename = attachment['filename']
        return filename if filename is not None else attachment['contentType']
    else:
        return os.path.basename(attachment)


def get_attachment_path(attachment):
    if isinstance(attachment, dict):
        received_attachment = os.path.join(SIGNALCLI_ATTACHMENT_FOLDER, str(attachment['id']))
        if not os.path.exists(received_attachment):
            received_attachment = os.path.join(SIGNALCLI_LEGACY_ATTACHMENT_FOLDER, str(attachment['id']))
        return received_attachment
    elif isinstance(attachment, str) and os.path.exists(attachment):
        return attachment


def b64_to_bytearray(group_id):
    return ','.join(str(i) for i in base64.b64decode(group_id.encode()))


def strftimestamp(timestamp, strformat='%H:%M:%S (%Y-%m-%d)'):
    try:
        date = datetime.utcfromtimestamp(timestamp)
    except ValueError:
        date = datetime.utcfromtimestamp(timestamp / 1000)
    return date.strftime(strformat)


# #############################################################################
# ui utility
# #############################################################################


def get_text_markup(text_widget):
    """Get urwid.Text widget text, in markup format.

    Like urwid.Text.get_text(), but returns a text markup that can be passed on to urwid.Text.set_text() or to urwid.Text() for creating a new text object"""

    text, display_attributes = text_widget.get_text()
    if not display_attributes:
        return text
    markup = []
    run_len_pos = 0
    for attr, attr_run_len in display_attributes:
        attr_run_end = run_len_pos + attr_run_len
        markup.append((attr, text[run_len_pos: attr_run_end]))
        run_len_pos = attr_run_end
    return markup


def listbox_set_body(listbox, body_new):
    # Can't just do `listbox.body = body_new`:
    # https://github.com/urwid/urwid/issues/428
    if body_new is listbox.body:
        return
    urwid.disconnect_signal(listbox.body, "modified", listbox._invalidate)
    listbox.body = body_new
    urwid.connect_signal(listbox.body, "modified", listbox._invalidate)


class FocusableText(urwid.WidgetWrap):
    def __init__(self, markup, **kwargs):
        self._text_w = urwid.Text(markup, **kwargs)
        w = urwid.AttrMap(self._text_w, None, focus_map=LIST_FOCUS_MAP)

        self.set_text = self._text_w.set_text

        super().__init__(w)

    def selectable(self):
        # Setting class variable `_selectable = True` does not work. Probably gets overwritten by the base class constructor.
        return True
    def keypress(self, size, key):
        # TODO: leave a comment: need keypress when reimplementing selecctable()
        return key

    @property
    def text(self):
        return self._text_w.text



class LazyEvalExtListWalker(urwid.ListWalker):

    def __init__(self, contents, eval_func, init_focus_pos=0):
        if not getattr(contents, '__getitem__', None):
            raise urwid.ListWalkerError("ListWalker expecting list like object, got: %r"%(contents,))
        self._init_focus_pos = init_focus_pos
        self.eval_func = eval_func
        self.contents = contents

    @property
    def contents(self):
        return self._contents

    @contents.setter
    def contents(self, contents_new):
        self._remove_contents_modified_callback()
        self._contents = contents_new
        self._set_contents_modified_callback(self._modified)

        if self._init_focus_pos < 0:
            self.focus = len(self.contents) + self._init_focus_pos
        else:
            self.focus = self._init_focus_pos

        self._modified()

    def _set_contents_modified_callback(self, callback):
        try:
            self.contents.set_modified_callback(callback)
        except AttributeError:
            logging.warning("Changes to object will not be automatically updated: %s", textwrap.shorten(str(self.contents), 150))
            pass

    def _remove_contents_modified_callback(self):
        try:
            self.contents.set_modified_callback(noop)
        except AttributeError:
            pass

    def _modified(self):
        logging.debug("called")
        if self.focus >= len(self.contents):
            self.focus = max(0, len(self.contents)-1)
        super()._modified()

    def __getitem__(self, position):
        item = self.contents[position]
        widget = self.eval_func(item, position)
        return widget

    def next_position(self, position):
        if position >= len(self.contents) - 1:
            raise IndexError
        return position + 1

    def prev_position(self, position):
        if position <= 0:
            raise IndexError
        return position - 1

    def set_focus(self, position):
        if position < 0 or position >= len(self.contents):
            raise IndexError
        self.focus = position
        self._modified()

    def positions(self, reverse=False):
        ret = range(len(self.contents))
        if reverse:
            ret = reversed(ret)
        return ret

class MessageWidgetsCache:

    OWN_NUM = None

    def __init__(self):
        self._cache = {}
        self._get_envelope_delivery_status = noop

    def get(self, msg, _position=None):
        key = self._hash(msg)
        try:
            w = self._cache[key]
        except KeyError:
            envelope = msg.envelope
            if is_envelope_outgoing(envelope):
                status = self._get_envelope_delivery_status(envelope)
            else:
                status = 'received_by_me'
            w = MessageWidget(envelope, status)
            self._cache[key] = w
        return w

    def _hash(self, msg):
        envelope = msg.envelope
        sender = envelope['source']
        timestamp = get_envelope_time(envelope)
        key = hash((sender, timestamp))
        return key

    def set_delivery_status_query_func(self, func):
        self._get_envelope_delivery_status = func

    def on_delivery_status_changed(self, timestamp, status):
        key = hash((self.OWN_NUM, timestamp))
        try:
            msg_w = self._cache[key]
        except KeyError:
            return
        msg_w.set_status(status)



class LazyEvalMessageListWalker(LazyEvalExtListWalker):
    def __init__(self, contents, init_focus_pos=-1):
        logging.debug("LazyEvalMessageListWalker: contents = %s", textwrap.shorten(str(contents), 150))
        self.msg_ws_cache = MessageWidgetsCache()
        super().__init__(contents, self.msg_ws_cache.get, init_focus_pos)


class ListBoxPlus(urwid.ListBox):

    def __init__(self, body=None):
        if body is None:
            body = []
        super().__init__(body)
        self._contents_pre_filter = self.contents

    def _get_contents(self):
        try:
            return self.body.contents
        except AttributeError:
            return self.body

    def _set_contents(self, contents_new):
        try:
            self.body.contents = contents_new
        except AttributeError:
            listbox_set_body(self, contents_new)

    def _set_contents_pre_filter(self, contents_new):
        if type(contents_new) is list:
            contents_new = type(self.contents)(contents_new)
            logging.debug("Created a new %s", textwrap.shorten(str(contents_new), 150))
        self._set_contents(contents_new)
        self._contents_pre_filter = self.contents
        logging.debug("self.contents = %s", textwrap.shorten(str(self.contents), 150))

    contents = property(_get_contents, _set_contents_pre_filter)

    def try_set_focus(self, index):
        if index < 0:
            index = len(self.contents) + index
        try:
            self.focus_position = index
        except IndexError:
            pass

    def filter_contents(self, function, scope=None):
        """doc-str here TODO

        Retain only the items in `self.contents` that return `True` when passed as arguments to `function`. Pre-filtered `contents` is stored before filtering and can be restored by running `filter_contents` again with `function=None`.
        The `scope` argument specifies the itarable to apply the filter to. By default, the scope is all the pre-filtered items. Passing `scope=self.contents' can be useful to further filter an already filtered contents.
        """

        if scope is None:
            scope = self._contents_pre_filter
        logging.debug("ListBoxPlus: filter_contents: scope = %s", textwrap.shorten(str(scope), 150))
        if function is None:
            self._set_contents(scope)
        else:
            contents_type = type(self.contents)
            matching_widgets = contents_type([w for w in scope if function(w)])
            logging.debug("ListBoxPlus: filter_contents: matching_widgets = %s", textwrap.shorten(str(matching_widgets), 150))
            self._set_contents(matching_widgets)

    @property
    def is_filter_on(self):
        logging.debug("ListBoxPlus: filter is on = %s", self.contents is not self._contents_pre_filter)
        return self.contents is not self._contents_pre_filter

    def keypress(self, size, key):
        orig_key = key
        key = super().keypress(size, key)
        if key == 'k':
            key = super().keypress(size, 'up')
        elif key == 'j':
            key = super().keypress(size, 'down')
        elif key == 'g':
            key = super().keypress(size, 'home')
        elif key == 'G':
            key = super().keypress(size, 'end')
        return key


class MessageWidget(urwid.WidgetWrap):

    cfg = None
    sigdata = None
    text_width = None

    @classmethod
    def init_class_attr(cls, cfg, sigdata):
        cls.cfg = cfg
        cls.sigdata = sigdata
        cls.set_text_width(cfg.wrap_at)

    @classmethod
    def set_text_width(cls, width):
        def bad_val(width):
            sys.exit(f"ERROR: Can't parse width value: `{width}`\nWidth value shoudld look like: `42` or `42.42%`.\nSee `--help` for additional info.")
        if width.endswith('%'):
            try:
                percent_width = float(width.rstrip('%'))
            except ValueError:
                bad_val(width)
            cls.text_width = ('relative', percent_width)
        else:
            try:
                cls.text_width = int(width)
            except ValueError:
                bad_val(width)

    def __init__(self, envelope, delivery_status):

        self.envelope = envelope
        logging.debug("envelope_txt = %s, delivery_status = %s", get_envelope_msg(envelope), delivery_status)

        self.align = 'left' if (not is_envelope_outgoing(self.envelope) or self.cfg.one_sided) else 'right'

        text_markup = self._get_text_markup(self.envelope)

        self.text_widget = FocusableText(text_markup, align=self.align)
        msg_pad_w = urwid.Padding(self.text_widget, self.align, width=self.text_width)
        status_markup = self._get_status_markup(delivery_status)
        self.status_w = urwid.Text(status_markup, self.align)
        status_w_valign = 'top' if self.align == 'left' else 'bottom'
        status_filler_w = urwid.Filler(self.status_w, status_w_valign)
        cols = [(DeliveryStatus.Markup.WIDTH, status_filler_w), msg_pad_w]
        box_columns = [0]
        if self.align == 'right':
            cols.reverse()
            box_columns = [1]
        columns_w = urwid.Columns(cols, dividechars=1, box_columns=box_columns)   # TODO: ? make dividechars a configurable value?
        display_w = urwid.AttrMap(columns_w, None, focus_map=LIST_FOCUS_MAP)
        super().__init__(display_w)

    def _get_text_markup(self, envelope):
        text_markup = self._format_msg(get_envelope_msg(envelope))
        if not isinstance(text_markup, list):
            text_markup = [text_markup]

        attachments = get_envelope_attachments(envelope)
        if attachments:
            text_markup = self._add_attachments_markup(text_markup, attachments)

        text_markup = self._add_sender_markup(text_markup, envelope)
        return text_markup

    def _format_msg(self, message):
        if not self.cfg.use_formatting:
            return ntxt(message)

        i, m = 0, []
        while i < len(message):
            c = message[i]
            if c in ('_', '*', '~'):
                try:
                    end = message[i + 1 :].index(c)
                    sub = message[i + 1 : i + 1 + end]
                    m.append(c)
                    m.append((FORMAT_MAP[c], sub))
                    m.append(c)
                    i = i + 2 + end
                except ValueError:
                    m.append(c)
                    i = i + 1
            else:
                m.append(c)
                i = i + 1

        if not m:
            m = " "
        return m

    def _add_attachments_markup(self, text_markup, attachments):
        attach_list = [get_attachment_name(attach) for attach in attachments]
        MAX_ATTACHS_SHOW = 4
        if len(attachments) > MAX_ATTACHS_SHOW:
            attach_list.append(f'... {len(attacments)-MAX_GROUP_SIZE} more.')
        attach_txt = ', '.join(attach_list)
        if isinstance(text_markup[0], tuple):
            if text_markup[0][1]:
                text_markup.append('\n')
        elif text_markup:
            text_markup.append('\n')
        text_markup += ['[attached: ', ('italic', attach_txt), ']']
        return text_markup

    def _add_sender_markup(self, text_markup, envelope):
        if is_envelope_outgoing(envelope):
            sender_markup = ('bolditalic', 'You') if self.cfg.show_names else None
        else:
            is_group = is_envelope_group_message(envelope)
            if is_group or self.cfg.show_names:
                source = envelope['source']
                contact = self.sigdata.get_contact(source)
                if contact:
                    sender_markup = ibtxt(get_contact_name(contact))
                else:
                    sender_markup = btxt(source)
            else:
                sender_markup = None

        if sender_markup:
            if self.align == 'left':
                text_markup = [sender_markup, ('bold', ' | ')] + text_markup
            else:
                text_markup += [('bold', ' | '), sender_markup]

        return text_markup

    def _get_status_markup(self, delivery_status):
        return DeliveryStatus.Markup.MAP[delivery_status]

    def set_status(self, status):
        logging.debug("MessageWidget: msg_text = `%s`, new status = %s", get_envelope_msg(self.envelope), status)
        status_markup_new = self._get_status_markup(status)
        self.status_w.set_text(status_markup_new)

    def __lt__(self, wtxt):
        return get_envelope_time(self.envelope) < get_envelope_time(wtxt.envelope)

class NiceBox(urwid.WidgetWrap):
    def __init__(self, w, title=''):
        box = urwid.AttrMap(urwid.LineBox(urwid.AttrMap(w, 'normal'), title_align='center', title=title), 'box_normal')
        w = urwid.AttrMap(box, None, focus_map={'box_normal': 'box_focused'})
        super().__init__(w)


class PopUpWrapper(urwid.WidgetWrap):
    signals = ['closed']

    def __init__(self, widget, title='', buttons=True):
        self._buttons = buttons
        if buttons:
            def handle_click(button):
                logging.debug("PopUpWrapper: button pressed!")
                self._emit('closed')
            btn_close = urwid.Padding(urwid.Button('Close', on_press=handle_click), align='center', width=9)  # TODO: 'pack' does not seem to work..
            self.frame_w = urwid.Frame(widget, footer=btn_close, focus_part='footer')
            box_w = urwid.LineBox(self.frame_w, title)
        else:
            box_w = urwid.LineBox(widget)
        super().__init__(box_w)

    def keypress(self, size, key):
        logging.debug("PopUpWrapper: got key = %s", key)
        key = super().keypress(size, key)
        logging.debug("PopUpWrapper: after super(), key = %s", key)
        if key == 'esc' or key == 'q':
            self._emit('closed')
        elif key == 'tab' or key == 'shift tab':
            if self._buttons:
                if self.frame_w.focus_position == 'footer':
                    self.frame_w.focus_position = 'body'
                else:
                    self.frame_w.focus_position = 'footer'
        else:
            return key
        return None



class MessageInfo(ListBoxPlus):
    def __init__(self, state, envelope):
        self.state = state

        source = envelope['source']
        msg = get_envelope_msg(envelope)
        date = None
        timestamp = get_envelope_time(envelope)
        date = strftimestamp(timestamp)
        status_detailed = self.state.delivery_status.get_detailed(envelope)

        txt_name = FocusableText([btxt('Sender : '), ntxt(get_contact_name(state.sigdata.get_contact(source)))])
        txt_source = FocusableText([btxt('Number : '), ntxt(source)])
        txt_date = FocusableText([btxt('Date   : '), ntxt(date)])
        txt_msg = FocusableText([btxt('Message: '), ntxt(msg)])

        items = [txt_name, txt_source, txt_date, txt_msg]

        status_str = status_detailed.str
        if status_str:
            status_when = f': {strftimestamp(status_detailed.when)}' if status_detailed.when else ''
            txt_status = FocusableText([btxt('Status : '), ntxt(status_str), status_when])
            items.append(txt_status)


        urls = get_urls(msg)
        if urls:
            txt_urls_header = FocusableText([btxt('Links')], align='center')
            txt_urls = []
            for url in urls:
                txt_url = FocusableText([ntxt(url)])
                txt_url.full_path = url
                txt_urls.append(txt_url)
            items.append(txt_urls_header)
            items.extend(txt_urls)


        attachments = get_envelope_attachments(envelope)
        if attachments:
            txt_atchs_header = FocusableText(btxt('Attachments'), align='center')
            txt_atchs = []
            for atch in attachments:
                txt_atch = FocusableText(ntxt(get_attachment_name(atch)))
                txt_atch.full_path = get_attachment_path(atch)
                txt_atchs.append(txt_atch)
            items.append(txt_atchs_header)
            items.extend(txt_atchs)

        super().__init__(items)

    def keypress(self, size, key):
        key = super().keypress(size, key)

        item = self.body[self.focus_position]

        if key == 'y':
            text = item.text
            try:
                clip.put(self.state, item.full_path)
            except AttributeError:
                try:
                    clip.put(self.state, text.split(": ")[1])
                except IndexError:
                    clip.put(self.state, text)
        elif key in ('enter', 'o'):
            try:
                self.state.commands.open_file(item.full_path)
            except (AttributeError, TypeError):
                pass
        else:
            return key

class HelpDialog(ListBoxPlus):
    def __init__(self):
        items = []
        items.append(urwid.Text(btxt("Keybindings")))
        items.append(urwid.Text(btxt("Commands")))
        super().__init__(items)




# #############################################################################
# clipboard
# #############################################################################


class clip:
    mime_order = ['image/png', 'image/jpeg', 'image/jpg', 'text/uri-list']
    tempfile_prefix = '_scli-tmp.'

    @staticmethod
    def xrun(mime):
        try:
            p = Popen(['xclip', '-selection', 'clipboard', '-t', mime, '-o'], stdout=PIPE, stderr=PIPE)
        except OSError:
            return
        out, err = p.communicate()
        return out

    @staticmethod
    def xrun_lines(mime):
        out = clip.xrun(mime)
        if out:
            return out.decode('utf-8').split('\n')

    @staticmethod
    def xfiles():
        out = clip.xrun_lines('TARGETS')

        for otype in out:
            for mtype in clip.mime_order:
                if mtype == otype:
                    if mtype.startswith('image/'):
                        content = clip.xrun(mtype)
                        suffix = '.' + mtype.split('/')[1]
                        tmp = tempfile.NamedTemporaryFile(
                            mode='w+b', prefix=clip.tempfile_prefix, suffix=suffix, delete=False
                        )
                        tmp.write(content)
                        tmp.flush()
                        tmp.close()
                        return [tmp.name]
                    elif mtype == 'text/uri-list':
                        content = clip.xrun_lines(mtype)
                        return [x.replace('file://', '') for x in content[1:]]

    @staticmethod
    def xput(txt):
        if not txt:
            return
        try:
            p = Popen(['xclip', '-selection', 'clipboard'], stdout=PIPE, stderr=PIPE, stdin=PIPE)
        except OSError:
            return
        p.stdin.write(bytes(txt, 'utf-8'))
        p.stdin.close()
        p.wait()

    @staticmethod
    def put(state, txt):
        cmd = state.cfg.clipboard_put_command
        if cmd == "":
            return clip.xput(txt)

        return mk_call(cmd, {'%s': txt})

    @staticmethod
    def files(state):
        cmd = state.cfg.clipboard_get_command
        if cmd == "":
            return clip.xfiles()

        return mk_call(cmd).split('\n')


# #############################################################################
# AsyncProc & Daemon
# #############################################################################


class AsyncProc:

    def __init__(self, urwid_loop):
        self._urwid_loop = urwid_loop

    def run(self, args, callback=None, *callback_args, shell=False, **callback_kwargs):
        """ Run the command composed of `args` in the background (asynchronously); run the `callback` function when it finishes """

        def watchpipe_handler(line):
            # This function is run when the shell process returns (finishes execution).
            # The `line` printed to watch pipe is of the form "b'<PID> <RETURN_CODE>\n'"
            _proc_pid, return_code = [int(i) for i in line.decode().split()]
            proc.wait()  # reap the child process, to prevent zombies

            proc.returncode = return_code   # overwrite the 'wrapper' command return code (always 0) with the actual command return code
            proc.output = proc.stderr.read().rstrip('\n')   # stderr stream is not seekable, so can be read only once

            if return_code != 0:
                logging.error('proc: cmd:`%s`; return_code:%d; output:"%s"', proc.args, return_code, proc.output)

            if callback is not None:
                callback(proc, *callback_args, **callback_kwargs)

            os.close(watchpipe_fd) # Close the write end of urwid's watch pipe.
            return False # Close the read end of urwid's watch pipe and remove the watch from event_loop.

        watchpipe_fd = self._urwid_loop.watch_pipe(watchpipe_handler)

        # If the command is run with Popen(.., shell=True), shlex.quote is needed to escape special chars in args.
        sh_command = " ".join([shlex.quote(arg) for arg in args] if not shell else ['{', args, ';', '}'])
        # Redirect all the process's output to stderr, and write the process PID and exit status to the watch pipe.
        sh_command += " 1>&2; echo $$ $?"

        proc = Popen(sh_command, shell=True, stdout=watchpipe_fd, stderr=PIPE, universal_newlines=True)
        atexit.register(proc.kill)   # prevent orphaned processes surviving after the main program is stopped
        return proc


class Daemon(AsyncProc):
    signals = ['receive_message', 'send_message', 'sending_done', 'receive_receipt']

    def __init__(self, urwid_loop, username):
        self.username = username
        self._buffer = b''
        super().__init__(urwid_loop)

    def start(self, username):
        stdout_fd = self._urwid_loop.watch_pipe(self._daemon_handler)
        stderr_fd = self._urwid_loop.watch_pipe(self._daemon_stderr_handler)
        return Popen(['signal-cli', '-u', self.username, 'daemon', '--json'], stdout=stdout_fd, stderr=stderr_fd, close_fds=True)

    def _daemon_handler(self, line):
        line = self._buffer + line
        lines = line.split(b'\n')
        if lines[-1] != b'':
            # Not a complete message. Store in buffer
            self._buffer = lines[-1]
        else:
            self._buffer = b''

        # The last item is either empty or an incomplete message, so we don't process it
        for line in lines[:-1]:
            if not line.strip():
                continue
            try:
                e = json.loads(line.decode('utf-8'))
                envelope = e['envelope']
                self._envelope_handler(envelope)
            except Exception as e:
                logging.error('input: %s', line)
                logging.exception(e)
                # TODO: display error to user
                continue

    def _daemon_stderr_handler(self, line):
        line = line.decode().strip()
        if not line:
            return
        logging.error('stderr: %s', line)

    def _envelope_handler(self, envelope):
        logging.debug("Daemon: envelope_handler: envelope = %s", envelope)
        if get_nested(envelope, 'syncMessage', 'sentMessage') is not None:
            urwid.emit_signal(self, 'send_message', envelope)
            urwid.emit_signal(self, 'sending_done', envelope)
        elif envelope.get('dataMessage') is not None:
            urwid.emit_signal(self, 'receive_message', envelope)
        elif envelope.get('receiptMessage') is not None:
            urwid.emit_signal(self, 'receive_receipt', envelope)
        else:
            logging.info('NOT_A_MESSAGE:%s', envelope)

    def dbus_send(self, args, *proc_args, async_proc=True, **proc_kwargs):
        """ Send a command to signal-cli daemon through dbus """
        args = [
                    'dbus-send',
                    '--session',
                    '--type=method_call',
                    '--print-reply',
                    '--dest=org.asamk.Signal',
                    '/org/asamk/Signal',
                    *args
                ]
        if async_proc:
            proc = self.run(args, *proc_args, **proc_kwargs)
        else:
            proc = subprocess.run(args, *proc_args, **proc_kwargs)
        return proc

    def _send_message_dbus_wrap(self, message, attachments, recipient, is_group=False, *proc_args, **proc_kwargs):
        args = [
                ('org.asamk.Signal.sendMessage'
                    if not is_group else
                    'org.asamk.Signal.sendGroupMessage'),
                'string:' + message,
                'array:string:' + ','.join(attachments),
                ('string:' + recipient
                    if not is_group else
                    'array:byte:' + b64_to_bytearray(recipient))
                ]

        self.dbus_send(args, *proc_args, **proc_kwargs)

    def send_message(self, contact, message="", attachments=[]):
        target = contact.get('number')
        is_group = target is None
        if is_group:
            target = contact.get('groupId')

        attachment_paths = [os.path.expanduser(attachment) for attachment in attachments]
        if not all([os.path.exists(attachment_path) for attachment_path in attachment_paths]):
            logging.warning('send_message: Attached file(s) does not exist.')
            return

        ts = int(datetime.now().timestamp() * 1000)
        envelope = {
            'source': self.username,
            'target': target,
            'timestamp': ts,
            'dataMessage': {'message': message, 'attachments': attachments, 'timestamp': ts},
        }

        def after_send_proc_returns(proc):
            # Remove temproary attachments
            for attachment in envelope['dataMessage']['attachments']:
                if attachment.startswith(os.path.join(tempfile.gettempdir(), clip.tempfile_prefix)):
                    os.remove(attachment)

            # Check if send command succeeded
            if proc.returncode != 0:
                urwid.emit_signal(self, 'sending_done', envelope, 'send_failed')
                return

            # Set envelope timestamp to that returned by signal-cli
            try:
                timestamp_adj = int(proc.output.rsplit(maxsplit=1)[1])
            except Exception as e:
                logging.error("send_message: Failed to get adjusted envelope timestamp")
                logging.exception(e)
                urwid.emit_signal(self, 'sending_done', envelope)
            else:
                urwid.emit_signal(self, 'sending_done', envelope, 'sent', timestamp_adj)


        self._send_message_dbus_wrap(message, attachment_paths, target, is_group, callback=after_send_proc_returns)

        logging.info('send_message:%s', envelope)
        urwid.emit_signal(self, 'send_message', envelope)


    def rename_contact(self, contact_id, new_name, is_group=False, *proc_args, **proc_kwargs):
        """Rename a contact or group.

        If a contact does not exist, it will be created. Changes to groups are sent to the server, changes to individual contacts are local.
        """
        if not is_group:
            args = ["org.asamk.Signal.setContactName",
                    "string:" + contact_id,
                    "string:" + new_name]
        else:
            args = ["org.asamk.Signal.updateGroup",
                    "array:byte:" + b64_to_bytearray(contact_id),
                    "string:" + new_name,
                    "array:string:" + '',   # members
                    "string:" + '']         # avatar
        self.dbus_send(args, *proc_args, **proc_kwargs)

urwid.register_signal(Daemon, Daemon.signals)


# #############################################################################
# signal
# #############################################################################


class SignalData:

    def __init__(self, user):
        self.user = user
        self._data = None
        self._path = os.path.join(SIGNALCLI_DATA_FOLDER, user)

        if not os.path.exists(self._path):
            self._path = os.path.join(SIGNALCLI_LEGACY_DATA_FOLDER, user)
            if not os.path.exists(self._path):
                raise Exception(self.user + " does not exist!")  # TODO: ? pick a more specific exception?


        self.reload()

    def reload(self):
        with open(self._path) as f:
            self._data = json.load(f)

        self.contacts = self._data['contactStore']['contacts']
        self.groups = [
            g
            for g in self._data["groupStore"]['groups']
            if g.get('name')
            # Older versions of `signal-cli` use `active` key while newer ones use `archived`.
            and (g.get('active') or not g.get('archived'))
        ]
        self.contacts_map = {c['number']: c for c in self.contacts}
        self.contacts_map.update({g['groupId']: g for g in self.groups})
        self.group_members = {g['groupId']: get_group_members(g, exclude=[self.user]) for g in self.groups}
        self.groups_w_contact = self._get_groups_w_contacts()
        self._add_contacts_profile_names()

    def _get_groups_w_contacts(self):
        ret = {}
        for group_id, group_members in self.group_members.items():
            for contact_num in group_members:
                if contact_num in self.contacts_map:
                    groups_w_contact_num = ret.setdefault(contact_num, set())
                    groups_w_contact_num.add(group_id)
        return ret

    def get_contact(self, contact_id):
        return self.contacts_map.get(contact_id)

    def get_envelope_contact(self, envelope):
        contact_id = get_envelope_contact_id(envelope)
        contact = self.get_contact(contact_id)
        if not contact:
            logging.critical('NULL_CONTACT:%s', envelope)
        return contact

    def _add_contacts_profile_names(self):
        try:
            profiles = self._data['profileStore']['profiles']
        except KeyError:
            return
        profiles_map = {p['name']: p for p in profiles}
        for contact in self.contacts:
            contact_num = contact['number']
            try:
                profile_name = profiles_map[contact_num]['profile']['name']
            except (KeyError, TypeError):
                profile_name = None
            contact['profile_name'] = profile_name


# #############################################################################
# commands
# #############################################################################


class Commands:
    def __init__(self, state):
        self.state = state
        self._urwid_loop = None
        self.cmd_mapping = [
            (['attach', 'a'], self.attach),
            (['edit', 'e'], self.external_edit),
            (['read', 'r'], self.read),
            (['attachClip', 'c'], self.attach_clip),
            (['openAttach', 'o'], self.open_last_attach),
            (['openUrl', 'u'], self.open_last_url),
            (['toggleNotifications', 'n'], self.toggle_notifications),
            (['toggleAutohide', 'h'], self.toggle_autohide),
            (['toggleContactsSort', 's'], self.toggle_sort_contacts),
            (['renameContact'], self.rename_contact),
            (['addContact'], self.add_contact),
            (['reload'], self.reload),
            (['quit', 'q'], self.quit),
        ]
        self.map = {cmd.lower(): fn for cmds, fn in self.cmd_mapping for cmd in cmds}

    def exec(self, cmd, *args):
        fn = self.map.get(cmd.lower())
        if fn is None:
            self.state.set_status_line(f"Command `{cmd}` not found")
            return
        if self.state.current_contact is None and fn in (
                self.external_edit, self.read, self.attach,
                self.attach_clip, self.open_last_attach,
                self.open_last_url):
            self.state.set_status_line(f":{cmd} Error: no contact currently selected")
            return
        try:
            return fn(*args)
        except TypeError as err:
            # Handle only the exceptions produced by giving the wrong number of arguments to `fn()`, not any exceptions produced inside executing `fn()` (i.e. deeper in the stack trace)
            if err.__traceback__.tb_next is not None:
                raise
            if re.search(r"missing \d+ required positional argument", str(err)):
                self.state.set_status_line(f':{cmd} missing arguments')
            elif re.search(r"takes \d+ positional arguments? but \d+ were given", str(err)):
                self.state.set_status_line(f':{cmd} extra arguments')
            else:
                raise

    def external_edit(self, *args):
        filename = ''
        if args:
            filename, *message = split_path(*args)

        if is_path(filename):
            msg_file_path = os.path.expanduser(filename)
        else:
            msg_file_path = tmpfile = tempfile.NamedTemporaryFile(suffix='.md', delete=False).name
            message = args
        if message:
            with open(msg_file_path, "w") as msg_file:
                msg_file.write(*message)

        self._urwid_loop.stop()
        mk_call(self.state.cfg.editor_command + " " + shlex.quote(msg_file_path), use_pipe=False)
        print('Please wait...')
        self._urwid_loop.start()

        with open(msg_file_path, 'r') as msg_file:
            msg = msg_file.read().strip()
            if msg:
                self.state.daemon.send_message(self.state.current_contact, msg)

        try:
            os.remove(tmpfile)
        except NameError:
            pass

    def read(self, path_or_cmd):
        message = ''
        if is_path(path_or_cmd):
            with open(os.path.expanduser(path_or_cmd), 'r') as file:
                message = file.read()
        elif path_or_cmd.startswith('!'):
            message = subprocess.check_output(['/bin/sh', '-c', path_or_cmd[1:].strip()]).decode("utf-8")

        if message != '':
            self.state.daemon.send_message(self.state.current_contact, message)

    def open_file(self, path):
        if os.path.exists(path):
            if isinstance(path, dict):
                mk_call(self.state.cfg.open_command, path, True)
            mk_call(self.state.cfg.open_command, {'%u': path}, True)

    def attach(self, args):
        attachment, *message = split_path(args)
        attachment = os.path.expanduser(attachment)
        if not os.path.isfile(attachment):
            self.state.set_status_line('File does not exist: ' + attachment)
            return
        self.state.daemon.send_message(self.state.current_contact, *message, attachments=[attachment])

    def attach_clip(self, *message):
        files = clip.files(self.state)

        if files:
            self.state.daemon.send_message(self.state.current_contact, *message, attachments=files)
        else:
            self.state.set_status_line('Clipboard is empty.')

    def open_attach(self, envelope):
        result = False
        attachments = get_envelope_attachments(envelope)
        for attachment in attachments:
            file_path = get_attachment_path(attachment)
            if file_path:
                self.open_file(file_path)
                result = True

        return result

    def open_last_attach(self):
        for txt in reversed(self.state.current_chat):
            if self.open_attach(txt.envelope):
                return

    def open_url(self, envelope):
        txt = get_envelope_msg(envelope)
        urls = get_urls(txt)
        if urls:
            mk_call(self.state.cfg.open_command, {'%u': urls[0]}, True)
            return True

        return False

    def open_last_url(self):
        for txt in reversed(self.state.current_chat):
            if self.open_url(txt.envelope):
                return

    def toggle_notifications(self):
        self.state.cfg.enable_notifications = not self.state.cfg.enable_notifications
        notif = 'Desktop notifications are ' + ('ON' if self.state.cfg.enable_notifications else 'OFF') + '.'
        self.state.set_status_line(notif)

    def toggle_autohide(self):
        self.state.cfg.contacts_autohide = not self.state.cfg.contacts_autohide

    def toggle_sort_contacts(self):
        self.state.cfg.contacts_sort_alpha = not self.state.cfg.contacts_sort_alpha
        self.reload()

    def send_notification(self, sender, message):
        if self.state.cfg.enable_notifications:
            mk_call(self.state.cfg.notification_command, {'%s': sender, '%m': message})

    def rename_contact(self, args):
        # :renameContact +NUMBER new name here  -> use +NUMBER number
        # :renameContact "Old Name" new name here  -> use contact named "Old Name"
        # :renameContact new name here          -> rename current contact or group
        try:
            number, new_name = split_path(args)
            if not is_number(number):
                for contact_id, contact in self.state.sigdata.contacts_map.items():
                    if contact["name"] == number:
                        is_group = is_contact_group(contact)
                        break
                else:  # contact with name `number` not found
                    raise ValueError
            elif self.state.sigdata.get_contact(number) is None:
                    self.state.set_status_line(f":renameContact Error: no contact with number {number} found")
                    return
            else:
                is_group = False
                contact_id = number
        except ValueError:
            if self.state.current_contact is None:
                self.state.set_status_line(":renameContact Error: no contact currently selected")
                return
            contact_id = self.state.current_contact.get('number')
            is_group = contact_id is None
            if is_group:
                contact_id = self.state.current_contact.get('groupId')
            new_name = args

        self.state.daemon.rename_contact(contact_id, new_name, is_group, lambda *i: self.reload())

    def add_contact(self, args):
        # :addContact +NUMBER [Contact Name]
        try:
            number, name = args.split(maxsplit=1)
        except ValueError:
            number, name = args, ""
        if not is_number(number):
            self.state.set_status_line(f':addContact "{number}": not a valid number')
            return
        self.state.daemon.rename_contact(number, name, is_group=False, callback=lambda *i: self.reload())

    def reload(self):
        self.state.reload()

    def quit(self):
        raise urwid.ExitMainLoop()



# #############################################################################
# ContactsWindow
# #############################################################################

class ContactWidget(FocusableText):

    SEND_FAILED_MARKUP = ''
    NOTE_TO_SELF_MARKUP = ('italic', ' (Self)')
    GROUP_MARKUP = ('italic', ' [GRP]')
    ADD_GRP_MARKUP = True
    OWN_NUM = ''

    def __init__(self, contact):
        self.contact = contact
        self._fail_mark_set = False
        self._unread_count = 0

        self.name_markup = self._mk_name_markup()
        super().__init__(self.name_markup)



    def _mk_name_markup(self):
        markup = []

        name = get_contact_name(self.contact)
        markup.append(name)
        if is_number(name):
            if name == self.OWN_NUM:
                markup.append(self.NOTE_TO_SELF_MARKUP)
            else:
                profile_name = self.contact.get('profile_name')
                if profile_name:
                    markup.append(('italic', ' ~' + profile_name))

        if is_contact_group(self.contact) and self.ADD_GRP_MARKUP:
            markup.append(self.GROUP_MARKUP)

        return markup

    @property
    def unread_count(self):
        return self._unread_count
    @unread_count.setter
    def unread_count(self, count):
        if count == self._unread_count:
            return
        self._unread_count = count
        unread_count_markup = '' if not count else [('bold', f"({count})"), " "]
        self.set_text([unread_count_markup, self.name_markup])

    @property
    def fail_mark_set(self):
        return self._fail_mark_set
    @fail_mark_set.setter
    def fail_mark_set(self, true_false):
        if self._fail_mark_set == true_false:
            return
        self._fail_mark_set = true_false
        fail_markup = [self.SEND_FAILED_MARKUP, " "] if self._fail_mark_set else [""]
        logging.debug("ContactWidget: fail_mark_set.setter: markup = %s", fail_markup)
        self.set_text(fail_markup + self.name_markup)

class ContactsWindow(ListBoxPlus):
    signals = [
            'unread_count_changed',
            'contact_selected',
            ]

    def __init__(self, state):
        logging.debug("ContactsWindow")
        super().__init__()

        self.state = state
        self.contact_widgets_map = {}
        self._current_contact = None

        ContactWidget.ADD_GRP_MARKUP = not self.state.cfg.group_contacts
        ContactWidget.OWN_NUM = self.state.cfg.username

        self.reload()

        urwid.connect_signal(self.state.daemon, 'receive_message', self.on_new_message)
        urwid.connect_signal(self.state.daemon, 'send_message', self.on_new_message)
        urwid.connect_signal(self.state.daemon, 'sending_done', self.on_sending_done)

    def reload(self):
        self.set_contacts(self.get_sorted_contacts())

    def get_sorted_contacts(self):
        def sorter(contact):
            contact_name = get_contact_name(contact)
            if self.state.cfg.contacts_sort_alpha:
                return contact_name.lower()
            try:
                chat = self.state.chats[hash_contact(contact)]
                last_envelope = chat[-1].envelope
            except (KeyError, IndexError):
                return (0, contact_name.lower())
            return (-get_envelope_time(last_envelope), contact_name.lower())

        if not self.state.cfg.group_contacts:
            return sorted(self.state.sigdata.contacts_map.values(), key=sorter)
        else:
            grps = sorted(self.state.sigdata.groups, key=sorter)
            conts = sorted(self.state.sigdata.contacts, key=sorter)
            return (grps, conts)

    def set_contacts(self, sorted_contacts):
        if not self.state.cfg.group_contacts:
            contact_widgets = [ContactWidget(contact) for contact in sorted_contacts]
            self.contents = contact_widgets
            self.contact_widgets_map = {hash_contact(w.contact): w for w in contact_widgets}
        else:
            group_contact_widgets = [ContactWidget(contact) for contact in sorted_contacts[0]]
            indiv_contact_widgets = [ContactWidget(contact) for contact in sorted_contacts[1]]
            div_w = urwid.Divider('-')
            indiv_cont_section_title = urwid.Text(btxt('~~ Contacts ~~'), align='center')
            widgets = group_contact_widgets + [div_w, indiv_cont_section_title, div_w] + indiv_contact_widgets
            self.contents = widgets
            self.contact_widgets_map = {hash_contact(w.contact): w for w in group_contact_widgets + indiv_contact_widgets}

        self._set_all_ws_unread_counts()

        self.try_set_focus(0)

    def _set_all_ws_unread_counts(self):
        for contact_id, contact_widget in self.contact_widgets_map.items():
            unread_count = self.state.unread_counts.get(contact_id, 0)
            if unread_count:
                logging.debug("ContactsWindow: set_contacts: contact_id = %s, unread_count = %s", contact_id, unread_count)
                contact_widget.unread_count = unread_count

    def set_contact_unread_count(self, contact, count):
        new_count = self.state.set_contact_unread_count(hash_contact(contact), count)
        total_unread_count = sum(self.state.unread_counts.values())
        urwid.emit_signal(self, 'unread_count_changed', total_unread_count)
        return new_count

    def on_new_message(self, envelope):
        if get_envelope_msg(envelope) is None and not get_envelope_attachments(envelope):
            return

        contact_id = get_envelope_contact_id(envelope)
        contact = self.state.sigdata.get_contact(contact_id)
        contact_widget = self.contact_widgets_map.get(contact_id)

        if contact != self._current_contact and not is_envelope_outgoing(envelope):
            new_count = self.set_contact_unread_count(contact, '+1')
            if contact_widget is not None:
                # NOTE: this happens when getting a msg from a 'new' contact (one not in the read signal-cli's data file)
                contact_widget.unread_count = new_count

        if not self.state.cfg.contacts_sort_alpha and contact_widget is not None:
            self.move_contact_top(contact_widget)

    def on_sending_done(self, envelope, status='sent', _timestamp_adj=None):
        if status != 'send_failed':
            return
        contact_id = get_envelope_contact_id(envelope)
        contact_widget = self.contact_widgets_map[contact_id]
        contact_widget.fail_mark_set = True

    def move_contact_top(self, w):
        if self.state.cfg.group_contacts:
            is_group = is_contact_group(w.contact)
            offset = 0 if is_group else (3 + len(self.state.sigdata.groups))
        else:
            offset = 0

        try:
            ind = self.body.index(w)
        except ValueError:
            # Widget might be absent from `body` e.g. while doing a search on contacts, or if the contact is 'new' (i.e. not in Signal._data yet)
            return

        if ind == offset:
            return
        self.body.insert(offset, self.body.pop(ind))

        self.focus_position = offset

    def _select_focused_contact(self):
        focused_contact_w = self.focus
        if focused_contact_w is None:
            # This can happen e.g. when searching through contacts returns no results
            return
        contact = focused_contact_w.contact
        self.set_contact_unread_count(focused_contact_w.contact, 0)
        focused_contact_w.unread_count = 0
        focused_contact_w.fail_mark_set = False
        self._current_contact = contact
        urwid.emit_signal(self, 'contact_selected', contact)


    def keypress(self, size, key):
        key = super().keypress(size, key)
        if key in ('enter', 'l'):
            self._select_focused_contact()
        elif key == 'r':
            self.state.reload()
        else:
            return key


class LeftWindow(urwid.Frame):
    def __init__(self, state):
        self.state = state
        self._wcontacts = ContactsWindow(self.state)
        self._wsearch = Edit(('bold', '/ '))  # looks better?

        urwid.connect_signal(self._wsearch, 'postchange', self.on_search_text_changed)

        super().__init__(self._wcontacts, footer=None)

        if not self.state.cfg.group_contacts:
            self.header = urwid.Pile([urwid.Text(btxt('Contacts'), align='center'), urwid.Divider('-')])
        else:
            self.header = urwid.Pile([urwid.Text(btxt('~~ Groups ~~'), align='center'), urwid.Divider('-')])

    def start_search(self):
        self.footer = self._wsearch
        self.focus_position = 'footer'

    def hide_search(self):
        self.focus_position = 'body'
        self.footer = None

    def clear_search(self):
        self._wsearch.set_edit_text('')


    def on_search_text_changed(self, input_w, _old_text):

        def match_test(contact_w):
            contact = contact_w.contact
            if isinstance(contact, str):  # TODO: is this still needed? Probably not - contact_w can't be str anymore
                return True
            return (txt.lower() in get_contact_name(contact).lower()) or (txt in get_contact_number(contact))

        txt = input_w.get_edit_text()
        match_test = None if not txt else match_test
        self._wcontacts.filter_contents(match_test)

    def keypress(self, size, key):
        key = super().keypress(size, key)
        if key == '/':
            self.start_search()
        elif key == 'enter' and self.focus_position == 'footer':
            self.focus_position = 'body'
        elif key == 'esc':
            self.hide_search()
            self.clear_search()
        else:
            return key


# #############################################################################
# ChatWindow
# #############################################################################

class CommandsHistory:

    def __init__(self):
        self._history = []
        self._index = 0
        self._stashed_input = None

    def prev(self, curr_input):
        if (curr_input != self._stashed_input
                and self._history
                and curr_input != self._history[self._index]):
            self._index = 0
        if self._index == 0:
            self._stashed_input = curr_input
        self._index -= 1
        try:
            return self._history[self._index]
        except IndexError:
            self._index += 1
            return curr_input

    def next(self, curr_input):
        if self._index == 0:
            return curr_input
        self._index += 1
        if self._index == 0:
            return self._stashed_input
        return self._history[self._index]

    def add(self, cmd):
        self._history.append(cmd)
        self._index = 0


class InputLine(Edit):  # NOTE: using urwid-readline Edit, if it exists

    def __init__(self, state, **kwargs):
        self.state = state
        self.cmd_history = CommandsHistory()

        self.current_contact = None

        prompt = ('bold', '> ')  # in urwid's parlance, this is called 'caption'
        super().__init__(prompt, **kwargs)

    def set_edit_text_move_cursor(self, txt, cursor_pos=-1):
        self.set_edit_text(txt)
        if cursor_pos == -1:
            cursor_pos = len(txt)
        self.set_edit_pos(cursor_pos)

    def auto_complete_commands(self, txt):
        splitted_txt = txt.split(' ')
        if len(splitted_txt) > 1:
            path, *messages = split_path(' '.join(splitted_txt[1:]))

            # Check we are trying to complete a path
            if len(messages) > 0 or not is_path(path):
                return

            fullpath = os.path.expanduser(path)
            dirname = os.path.dirname(fullpath)
            if not os.path.isdir(dirname):
                return

            possible_paths = [x for x in os.listdir(dirname) if os.path.join(dirname, x).startswith(fullpath)]
            commonprefix = os.path.commonprefix(possible_paths)

            self.state.set_status_line('|'.join(possible_paths))

            completion = ''
            if commonprefix != '':
                completion = os.path.join(os.path.dirname(path), commonprefix)
            if os.path.isdir(os.path.expanduser(completion)) and not completion.endswith('/'):
                completion = completion + '/'
            if ' ' in completion:
                completion = '"' + completion + '"'

            if completion != '':
                self.set_edit_text_move_cursor(splitted_txt[0] + ' ' + completion)
        else:
            all_commands = [
                cmd
                for cmd in [tupl[0][0] for tupl in self.state.commands.cmd_mapping]
                if cmd.lower().startswith(txt[1:].lower())
            ]
            commonprefix = os.path.commonprefix(all_commands)

            self.state.set_status_line('{' + '|'.join(all_commands) + '}')

            if len(all_commands) == 1:
                self.set_edit_text_move_cursor(':' + all_commands[0] + ' ')
            elif commonprefix != '':
                self.set_edit_text_move_cursor(':' + commonprefix)

    def keypress(self, size, key):

        key_orig = key
        key = super().keypress(size, key)
        logging.debug("InputLine: keypress: got key = %s; after super(), key = %s", key_orig, key)

        txt = self.get_edit_text()

        if not txt or txt.isspace():
            return key
        elif key == 'esc' and txt.startswith(('/', ':')):
            self.set_edit_text('')
        elif txt.startswith(':'):
            if key == 'enter':
                if txt.strip() == ":":
                    self.state.set_status_line('Command missing after `:`')
                    return None
                cmd, *args = txt[1:].split(maxsplit=1)
                self.state.commands.exec(cmd, *args)
                self.cmd_history.add(txt)
                self.set_edit_text('')
            elif key == 'tab' and not self.get_edit_text().endswith(' '):
                self.auto_complete_commands(txt)
            elif key == 'up':
                prev_cmd = self.cmd_history.prev(txt)
                self.set_edit_text_move_cursor(prev_cmd)
            elif key == 'down':
                next_cmd = self.cmd_history.next(txt)
                self.set_edit_text_move_cursor(next_cmd)
            else:
                return key
        elif not self.current_contact:
            return key
        elif txt.startswith('/') and key == 'enter':
            return key
        elif key == 'enter':
            self.state.daemon.send_message(self.current_contact, txt)
            self.set_edit_text('')
        else:
            return key



class MessagesListBox(ListBoxPlus):

    def __init__(self, state):
        logging.debug("MessagesListBox")
        self.state = state

        lw = LazyEvalMessageListWalker(urwid.MonitoredList())
        super().__init__(lw)

        urwid.connect_signal(self.state.daemon, 'receive_message', self.on_new_message)
        urwid.connect_signal(self.state.daemon, 'send_message', self.on_new_message)
        urwid.connect_signal(self.state.daemon, 'sending_done', self.on_new_message)

        logging.debug("MessagesListBox: howdy!")

    def on_new_message(self, _envelope, *args):
        logging.debug("MessagesListBox: setting focus for env(txt) = %s", get_envelope_msg(_envelope))
        self.try_set_focus(-1)

    def reset_search(self, keep_curr_focused=False):
        logging.debug("MessagesListBox: reset_search()")
        curr_focused_msg = self.focus
        self.filter_contents(None)
        if keep_curr_focused:
            focus_position = self.state.get_chat_index_for_envelope(self.contents, curr_focused_msg.envelope)
            self.try_set_focus(focus_position)

    def update_search_results(self, txt, old_txt=''):
        if not txt:
            return
        scope = self.contents if txt.startswith(old_txt) else None
        logging.debug("MessagesListBox: update_search_results: txt = %s, old_txt = %s, txt.startswith(old_txt) = %s", txt, old_txt, txt.startswith(old_txt))
        def test_match(msg_w):
            return txt in get_envelope_msg(msg_w.envelope)
        self.filter_contents(test_match, scope)
        self.try_set_focus(-1)

    def on_input_line_change(self, input_line_w, old_text):
        txt = input_line_w.get_edit_text()
        logging.debug("MessagesListBox: on_input_line_change: txt = %s, old_text = %s", txt, old_text)
        if txt.startswith('/'):
            self.update_search_results(txt[1:], old_text[1:])
        elif self.is_filter_on:
            self.reset_search()

    def keypress(self, size, key):
        key = super().keypress(size, key)

        message_widget = self.focus
        if message_widget is None:
            return key
        envelope = message_widget.envelope

        if key in ('enter', 'l'):
            if self.is_filter_on:
                self.reset_search(keep_curr_focused=True)
            else:
                self.state.commands.open_attach(envelope) or self.state.commands.open_url(envelope)
        elif key == 'o':
            self.state.commands.open_url(envelope) or self.state.commands.open_attach(envelope)
        elif key == 'y':
            txt = get_envelope_msg(envelope)
            clip.put(self.state, txt)
        elif key == 'd':
            logging.debug("MessagesListBox: kepress: `d`: envelope = %s", envelope)
            if self.is_filter_on:
                del self.contents[self.focus_position]
                self.state.delete_message(envelope)
            else:
                self.state.delete_message(envelope, self.focus_position)
        elif key == 'r':
            if self.state.delivery_status.get_str(envelope) != 'send_failed':
                return
            if self.is_filter_on:
                logging.debug("MessagesListBox: keypres `r`: filter_on, resending")
                self.state.resend_message(envelope)
                self.reset_search()
                self.try_set_focus(-1)
            else:
                self.state.resend_message(envelope, self.focus_position)
        else:
            return key


class ChatWindow(urwid.Frame):

    def __init__(self, state):
        logging.debug("ChatWindow")
        self.state = state

        self.title_widget = urwid.Text('', align='center')
        self.input_line_w = InputLine(state)
        self.msgs_list = MessagesListBox(state)

        title_w_div = urwid.Pile([self.title_widget, urwid.Divider('-')])
        input_w_div = urwid.Pile([urwid.Divider('-'), self.input_line_w])
        self._focusable_widgets = {'chat': 'body', 'input': 'footer'}

        super().__init__(self.msgs_list, header=title_w_div, footer=input_w_div)

        urwid.connect_signal(self.input_line_w, 'postchange', self.msgs_list.on_input_line_change)

    @property
    def focus_widget_name(self):
        for widget_name, focus_pos in self._focusable_widgets.items():
            if focus_pos == self.focus_position:
                return widget_name

    @focus_widget_name.setter
    def focus_widget_name(self, widget_name):
        self.focus_position = self._focusable_widgets[widget_name]

    def set_title(self, contact):
        num = contact.get("number")
        if not num:
            # see this: https://github.com/isamert/scli/issues/53#issuecomment-612571462
            contacts = [
                self.state.sigdata.get_contact(contact if isinstance(contact, str) else contact['number']) or contact
                for contact in contact['members']
            ]
            num = ', '.join([get_contact_name(contact) for contact in contacts])

        self.title_widget.set_text([('bold', get_contact_name(contact)), ' (', num, ')'])

    def on_contact_selected(self, contact):
        self.set_title(contact)
        self.msgs_list.try_set_focus(-1)
        self.input_line_w.current_contact = contact

    def keypress(self, size, key):
        key = super().keypress(size, key)
        if key == 'esc' and self.input_line_w.edit_text.startswith('/'):
            self.input_line_w.set_edit_text('')
        return key


# #############################################################################
# MainWindow
# #############################################################################

class StatusLine(urwid.Columns):

    def __init__(self, unread_count=0):
        self._text = urwid.Text('')
        self.unreads_widget = urwid.Text(["Unread messages count: ", ('bold', f"{unread_count}")])
        super().__init__([self.text, ('pack', self.unreads_widget)], dividechars=1)

    @property
    def text(self):
        return self._text
    @text.setter
    def text(self, new_text):
        self.set_text(new_text)

    def set_text(self, new_text):
        self._text.set_text(new_text)

    def set_unread_count(self, count):
        txt = str(count) if count else str()
        self.unreads_widget.set_text(('bold', txt))


class MainWindow(urwid.WidgetWrap):

    def __init__(self, state):
        self.state = state

        self._wleft = LeftWindow(self.state)
        self._wchat = ChatWindow(self.state)

        self._wrapped_left = NiceBox(self._wleft)
        self.wrapped_chat = NiceBox(self._wchat)
        self._wplaceholder = urwid.WidgetPlaceholder(self.wrapped_chat)
        cols = [('weight', 1, self._wrapped_left), ('weight', 3, self._wplaceholder)]
        self._wcolumns = urwid.Columns(cols)
        self._contacts_column = self._wcolumns.contents[0]

        total_unread_count = sum(self.state.unread_counts.values())
        self.status_line = StatusLine(total_unread_count)

        w = urwid.Frame(self._wcolumns, footer=self.status_line)
        super().__init__(w)

        urwid.connect_signal(self.state, 'reload_request', self.reload)
        urwid.connect_signal(self._wleft._wcontacts, 'contact_selected', self.on_contact_selected)
        urwid.connect_signal(self.state, 'set_status_line', self.status_line.set_text)
        urwid.connect_signal(self.state.cfg, 'changed', self.on_cfg_changed)
        urwid.connect_signal(self._wleft._wcontacts, 'unread_count_changed', self.status_line.set_unread_count)

    @property
    def _contacts_hidden(self):
        return self._contacts_column not in self._wcolumns.contents

    @_contacts_hidden.setter
    def _contacts_hidden(self, yes_no):
        if yes_no and not self._contacts_hidden:
            self._wcolumns.contents.remove(self._contacts_column)
        elif not yes_no and self._contacts_hidden:
            self._wcolumns.contents.insert(0, self._contacts_column)

    @property
    def focus_widget_name(self):
        if self._contacts_hidden or self._wcolumns.focus_position == 1:
            return self._wchat.focus_widget_name
        return 'contacts'

    @focus_widget_name.setter
    def focus_widget_name(self, widget_name):
        if widget_name == 'contacts':
            self._contacts_hidden = False
            self._wcolumns.focus_position = 0
        else:
            if self.state.cfg.contacts_autohide and not self._contacts_hidden:
                self._contacts_hidden = True
            self._wcolumns.focus_position = 0 if self._contacts_hidden else 1
            self._wchat.focus_widget_name = widget_name

    def focus_next(self, reverse=False):
        wnames = ['contacts', 'chat', 'input']
        curr_wname = self.focus_widget_name
        if not self._wchat.msgs_list.body and not curr_wname == 'chat':
            wnames.remove('chat')
        curr_focus_pos = wnames.index(curr_wname)
        incr = -1 if reverse else 1
        next_wname = wnames[(curr_focus_pos + incr) % len(wnames)]
        self.focus_widget_name = next_wname

    def reload(self):
        self._wleft._wcontacts.reload()

    def show_pop_up(self, widget, title=''):
        wrapper = PopUpWrapper(widget, title)
        urwid.connect_signal(wrapper, 'closed', self.remove_pop_up)

        self._wplaceholder_orig = self._wplaceholder.original_widget

        popup = urwid.Overlay(
            wrapper,
            self._wplaceholder_orig,
            align='center',
            valign='middle',
            width=('relative', 85),
            height=('relative', 65),
        )

        self._wplaceholder.original_widget = popup

    def remove_pop_up(self, _sender=None):
        self._wplaceholder.original_widget = self._wplaceholder_orig

    def show_help_pop_up(self):
        self.show_pop_up(HelpDialog(), title='Help')

    def show_message_info_pop_up(self):
        message_widget = self._wchat.msgs_list.focus
        if message_widget is None:
            return key
        envelope = message_widget.envelope

        self.show_pop_up(urwid.Filler(MessageInfo(self.state, envelope), height=('relative', 100), top=1, bottom=1), title='Message info')

    def on_contact_selected(self, contact):
        self.status_line.text = ''

        self.focus_widget_name = 'input'

        self.state.set_current_contact(contact)
        contents_new = self.state.current_chat
        logging.debug("contents_new = %s", textwrap.shorten(str(contents_new), 150))
        self._wchat.msgs_list.contents = contents_new
        self._wchat.on_contact_selected(contact)

    def on_cfg_changed(self, key, val):
        if key == 'contacts_autohide':
            self._contacts_hidden = not self._contacts_hidden

    def keypress(self, size, key):
        if key == 'enter' and self.focus_widget_name == 'input' and self._wchat.input_line_w.edit_text.startswith('/'):
            if not self._wchat.msgs_list.is_filter_on:
                urwid.emit_signal(self._wchat.input_line_w, 'postchange', self._wchat.input_line_w, '/')
            if self._wchat.msgs_list.body:
                self.focus_widget_name = 'chat'
            return None

        key = super().keypress(size, key)

        if key == 'tab':
            self.focus_next()
        elif key == 'shift tab':
            self.focus_next(reverse=True)
        elif key == ':':
            self.focus_widget_name = 'input'
            self._wchat.input_line_w.set_edit_text_move_cursor(':')
        elif key == '/' and self.focus_widget_name == 'chat':
            self.focus_widget_name = 'input'
            self._wchat.input_line_w.set_edit_text_move_cursor('/')
        elif key == '?':
            self.show_help_pop_up()
        elif key == 'i' and self.focus_widget_name == 'chat' and self._wplaceholder.original_widget == self.wrapped_chat:
            self.show_message_info_pop_up()
        else:
            return key


# #############################################################################
# state
# #############################################################################


class Message:


    def __init__(self, envelope):
        self.envelope = envelope

    def __lt__(self, other_msg):
        return get_envelope_time(self.envelope) < get_envelope_time(other_msg.envelope)


class MessagesList(urwid.MonitoredList):
    pass


class State:
    signals = [
        'set_status_line',
        'reload_request',
    ]


    def __init__(self, cfg):
        logging.debug("State")
        self.sigdata = SignalData(cfg.username)
        self.daemon = Daemon(None, cfg.username)
        self.cfg = cfg
        self.chats = collections.defaultdict(MessagesList)


        self.current_contact = None
        self.current_chat = None
        self.unread_counts = {}

        self.commands = Commands(self)

        self.delivery_status = DeliveryStatus(self.sigdata)

        MessageWidget.init_class_attr(self.cfg, self.sigdata)

        self.load_history()
        atexit.register(self.save_history)



    def reload(self):
        self.sigdata.reload()
        if self.current_contact is not None:
            contact_id = get_contact_id(self.current_contact)
            current_contact_reloaded = self.sigdata.get_contact(contact_id)
            self.set_current_contact(current_contact_reloaded)
        urwid.emit_signal(self, 'reload_request')

    def set_current_contact(self, contact):
        self.current_contact = contact
        self.current_chat = self.chats[hash_contact(contact)]

    def set_status_line(self, text):
        logging.debug("State: set_status_line: text = %s", text)
        urwid.emit_signal(self, 'set_status_line', text)

    def set_contact_unread_count(self, contact_id, count):
        if count == '+1':
            count = self.unread_counts.get(contact_id, 0) + 1
        self.unread_counts[contact_id] = count
        return count

    def get_chat_for_envelope(self, envelope):
        contact = self.sigdata.get_envelope_contact(envelope)
        return self.chats[hash_contact(contact)]

    def get_chat_index_for_envelope(self, chat, envelope):
        dummy_message = Message(envelope)
        index = bisect.bisect_left(chat, dummy_message)
        if index != len(chat) and chat[index].envelope == envelope:
            return index
        raise ValueError

    def delete_message(self, envelope, index=None):
        self.delivery_status.delete(envelope)

        chat = self.get_chat_for_envelope(envelope)
        try:
            if index is None:
                index = self.get_chat_index_for_envelope(chat, envelope)
            del chat[index]
            logging.debug("State: delete_message: deleted msg env = %s", envelope)
        except (ValueError, IndexError):
            pass

    def resend_message(self, envelope, index=None):
        self.delete_message(envelope, index)
        self.set_status_line('') # remove 'send-failed' status line

        contact = self.sigdata.get_envelope_contact(envelope)
        message = get_envelope_msg(envelope)
        attachments = get_envelope_attachments(envelope)
        self.daemon.send_message(contact, message, attachments)

    def on_send_message(self, envelope):
        msg_widget = self.add_env_to_chats(envelope)

    def on_receive_message(self, envelope):
        msg = get_envelope_msg(envelope)

        if msg is None:
            logging.info('NOT_A_MESSAGE:%s', envelope)
            return
        logging.info('MESSAGE:%s', envelope)

        sender = self.sigdata.get_envelope_contact(envelope)
        contact_name = get_contact_name(sender)

        if sender != self.current_contact:
            notif = 'New message from ' + contact_name + ': "' + msg + '"'
            notif = textwrap.shorten(notif, 80)  # TODO: best width = ?
            self.set_status_line(notif)

        self.commands.send_notification(contact_name, msg)

        msg_widget = self.add_env_to_chats(envelope)

    def on_sending_done(self, envelope, status='sent', timestamp_adj=None):
        try:
            chat = self.get_chat_for_envelope(envelope)
            index = self.get_chat_index_for_envelope(chat, envelope)
            msg_widget = chat[index]
        except (KeyError, ValueError, IndexError) as e:
            logging.error("on_sending_done(): envelope = %s", envelope)
            logging.exception(e)
            return

        if status == 'send_failed':
            msg_shortened = textwrap.shorten(get_envelope_msg(envelope), 20)  # TODO
            self.set_status_line(f'Message "{get_envelope_msg(envelope)[:20]}" failed to send. Press `r` on message to re-send.')
            return

        if timestamp_adj is not None:
            msg_widget.envelope['timestamp'] = msg_widget.envelope['dataMessage']['timestamp'] = timestamp_adj

    def add_env_to_chats(self, envelope, add_func=bisect.insort):
        wmsg = Message(envelope)
        chat = self.get_chat_for_envelope(envelope)
        add_func(chat, wmsg)

        return wmsg

    def save_history(self):
        if not self.cfg.save_history:
            return

        envelopes = [x.envelope for vals in self.chats.values() for x in vals]
        unread_counts = {contact_id: count for (contact_id, count) in self.unread_counts.items() if count != 0}
        items = {'envelopes': envelopes, 'unread_counts': unread_counts, 'delivery_status': self.delivery_status.dump()}

        class JSONSetEncoder(json.JSONEncoder):
            def default(self, o):
                try:
                    return json.JSONEncoder.default(self, o)
                except TypeError:
                    if isinstance(o, set):
                        return tuple(o)
                    raise

        with open(SCLI_HISTORY_FILE, 'w') as history_file:
            json.dump(items, history_file, ensure_ascii=False, cls=JSONSetEncoder)

    def load_history(self):
        if not self.cfg.save_history or not os.path.exists(SCLI_HISTORY_FILE):
            return

        with open(SCLI_HISTORY_FILE, 'r') as history_file:
            history = json.load(history_file)

        self.delivery_status.load(history.get('delivery_status', {}))

        def append_message(chat, msg_w):
            chat.append(msg_w)

        for envelope in history['envelopes']:
            self.add_env_to_chats(envelope, append_message)

        self.unread_counts = history.get('unread_counts', {})


urwid.register_signal(State, State.signals)


# #############################################################################
# DeliveryStatus
# #############################################################################


class DeliveryStatus:
    signals = ['delivery_status_changed']

    DelivReadConts = collections.namedtuple('DelivReadConts', ['delivered', 'read'])

    class DetailedStatus:

        __slots__ = ("str", "when", "grp_memb_remain_un")

        def __init__(self, status='', when=0, grp_memb_remain_un=None):
            self.str = status
            self.when = when
            if grp_memb_remain_un:
                self.grp_memb_remain_un = DeliveryStatus.DelivReadConts(*(set(contacts) if contacts else set() for contacts in grp_memb_remain_un))

        def set_grp_memb_status(self, grp_member, status):
            try:
                grp_memb_remain_un = self.grp_memb_remain_un
            except AttributeError:
                return None
            grp_memb_remaining = getattr(grp_memb_remain_un, status)
            try:
                grp_memb_remaining.remove(grp_member)
            except (KeyError, AttributeError):
                # This happens when 'read' receipt arrives before 'delivered', or after getting multiple copies of the same receipt message.
                grp_memb_remaining = grp_memb_remain_un.delivered
                try:
                    grp_memb_remaining.remove(grp_member)
                except (KeyError, AttributeError):
                    return None
                if not grp_memb_remain_un.delivered and grp_memb_remain_un.read:
                    return 'delivered'

            if status == 'delivered':
                remaining_unread = grp_memb_remain_un.read
                remaining_unread.add(grp_member)
                if grp_memb_remaining:
                    return None
                return status

            if any(grp_memb_remain_un):
                return None
            del self.grp_memb_remain_un
            return status

        def serialize(self):
            ret = []
            for attr in self.__slots__:
                val = getattr(self, attr, None)
                ret.append(val)

            # Skip empty values at the end
            for ind, val in enumerate(reversed(ret)):
                if val:
                    if ind != 0:
                        ret = ret[:-ind]
                    break
            else:
                ret = []

            return ret

    class Markup:

        def _make_markup_map():
            status_text = {
                    # Order matters: 'higher' status can't be 're-set' to a 'lower' one.
                    '':                 '<<',
                    'received_by_me':   '>>',
                    'sending':          '',
                    'send_failed':      '',
                    'sent':             '',
                    'delivered':        '',
                    'read':             '',
                    'ignore_receipts':  '',
                    }

            max_len = max([len(text) for text in status_text.values()])

            markup_map = {}
            for status, text in status_text.items():
                markup_map[status] = ('bold', text) if status not in ('read', 'ignore_receipts') else ('strikethrough', text)

            return (markup_map, max_len)

        MAP, WIDTH = _make_markup_map()


    def __init__(self, sigdata):
        self.sigdata = sigdata

        self._status_map = {}
        self._buffered = {}
        self.MAX_GROUP_SIZE = 15

        self._status_order = {key: ind for ind, key in enumerate(self.Markup.MAP)}

    def get_detailed(self, envelope):
        return self._status_map.get(get_envelope_time(envelope), self.DetailedStatus())

    def get_str(self, envelope):
        return self.get_detailed(envelope).str

    def on_receive_receipt(self, envelope):
        # NOTE: Receipt message structure would be different then assumed here if the sent message was not a "sealed sender" one:
        # https://github.com/AsamK/signal-cli/issues/346
        receipt_contact = envelope['source']
        receipt_message = envelope['receiptMessage']
        if receipt_message['isDelivery']:
            status = 'delivered'
        elif receipt_message['isRead']:
            status = 'read'
        timestamps = receipt_message['timestamps']
        when = receipt_message['when']
        for timestamp in timestamps:
            if timestamp not in self._status_map:
                self.buffer_receipt(timestamp, status, receipt_contact)
            else:
                self.set(timestamp, status, when, receipt_contact)

    def on_send_message(self, envelope):
        timestamp = get_envelope_time(envelope)
        self.set(timestamp, 'sending')
        if is_envelope_group_message(envelope):
            group_id = get_envelope_contact_id(envelope)
            group_members = self.sigdata.group_members[group_id]
            self.set_group_members(timestamp, group_members)

    def on_sending_done(self, envelope, status='sent', timestamp_adj=None):
        timestamp = get_envelope_time(envelope)
        logging.debug("DeliveryStatus: timestamp = %s, status = %s, timestamp_adj = %s", timestamp, status, timestamp_adj)
        if timestamp not in self._status_map:
            logging.error("DeliveryStatus: on_sending_done(): no 'sent' status in status map for envelope = %s", envelope)
            return
        self.set(timestamp, status)
        if status == 'send_failed':
            return
        if timestamp_adj is not None:
            self.adjust_timestamp(timestamp, timestamp_adj)
            timestamp = timestamp_adj
        self.process_buffered_receipts(timestamp)

    def adjust_timestamp(self, timestamp_orig, timestamp_adj):
        self._status_map[timestamp_adj] = self._status_map.pop(timestamp_orig)

    def set(self, timestamp, status, when=None, receipt_contact=None):
        curr_status_detailed = self._status_map.setdefault(timestamp, self.DetailedStatus())
        curr_status = curr_status_detailed.str

        if self._status_order[status] <= self._status_order[curr_status]:
            return

        is_group = getattr(curr_status_detailed, 'grp_memb_remain_un', False)
        if is_group and receipt_contact is not None:
            status = curr_status_detailed.set_grp_memb_status(receipt_contact, status)
            if status is None:
                return

        curr_status_detailed.str = status
        if when is not None:
            curr_status_detailed.when = when
        logging.debug("Setting status = `%s` for timestamp = %s", status, timestamp)
        urwid.emit_signal(self, 'delivery_status_changed', timestamp, status)

    def set_group_members(self, timestamp, group_members):
        status_detailed = self._status_map[timestamp]

        if len(group_members) > self.MAX_GROUP_SIZE:
            self.set(timestamp, 'ignore_receipts')
            return

        status_detailed.grp_memb_remain_un = self.DelivReadConts(set(group_members), set())

    def buffer_receipt(self, timestamp, status, contact):
        logging.debug("DeliveryStatus: buffering timestamp = %s", timestamp)
        buffered = self._buffered.setdefault(timestamp, self.DelivReadConts(set(), set()))
        buffered_contacts = getattr(buffered, status)
        buffered_contacts.add(contact)

    def process_buffered_receipts(self, timestamp):
        logging.debug("Processing buffered receipts: timestamp = %s, self._buffered = %s", timestamp, self._buffered)
        buffered = self._buffered.get(timestamp)
        if buffered is None:
            return
        status_detailed = self._status_map[timestamp]
        for status in buffered._fields:
            buffered_contacts = getattr(buffered, status) or []
            for contact in buffered_contacts:
                self.set(timestamp, status, receipt_contact=contact)
        del self._buffered[timestamp]

    def delete(self, envelope):
        try:
            del self._status_map[get_envelope_time(envelope)]
        except KeyError:
            pass

    def dump(self):
        ret = {}
        for timestamp, status_detailed in self._status_map.items():
            status_serialized = status_detailed.serialize()
            if status_serialized:
                ret[timestamp] = status_serialized
        return ret

    def load(self, status_map):
        for timestamp, status_detailed in status_map.items():
            self._status_map[int(timestamp)] = self.DetailedStatus(*status_detailed)

urwid.register_signal(DeliveryStatus, DeliveryStatus.signals)


# #############################################################################
# main
# #############################################################################


def parse_cfg_file(cfg_file_path):
    vars = {}
    cfg_file_path = os.path.expanduser(cfg_file_path)
    if os.path.exists(cfg_file_path):
        with open(cfg_file_path) as cfg_file:
            for line in cfg_file:
                if not line.startswith('#') and line.strip() != "":
                    name, var = line.partition("=")[::2]
                    vars[name.strip().replace('-', '_')] = var.strip()
    elif cfg_file_path != SCLI_CFG_FILE and cfg_file_path != "":
        print('Given config file not found: ' + cfg_file_path, file=sys.stderr)
        sys.exit(2)

    return vars

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-c',
        '--config-file',
        type=str,
        default=SCLI_CFG_FILE,
        help='Config file. Configs in this file overrides every other config supplied by command line. (Default: '
        + SCLI_CFG_FILE
        + ')',
    )

    parser.add_argument('-u', '--username', type=str, help='Phone number starting with "+" followed by country code.')

    parser.add_argument(
        '-n',
        '--enable-notifications',
        default=False,
        action='store_true',
        help='Enable desktop notifications. (Also see --notification-command)',
    )

    parser.add_argument(
        '-N',
        '--notification-command',
        type=str,
        default="notify-send scli '%s - %m'",
        help='The command to run when a new message arrives. %%m is replaced with the message, %%s is replaced with the sender. (Default is "notify-send scli \'%%s - %%m\'',
    )

    parser.add_argument(
        '-o',
        '--open-command',
        type=str,
        default='xdg-open "%u"',
        help='File/URL opener command. %%u is replaced with the path. (Default is "xdg-open %%u")',
    )

    parser.add_argument(
        '-e',
        '--editor-command',
        type=str,
        default='$EDITOR',
        help='A text editor command to edit your messages externally.',
    )

    parser.add_argument(
        '-G',
        '--clipboard-get-command',
        type=str,
        default="",
        help='A command that returns a valid file path(s). When user calls `:attachClip` or `:c`, this command is executed and the returned file(s) will be added as attachment(s). The command should return one absolute file path per each line. (Default uses `xclip`)',
    )

    parser.add_argument(
        '-P',
        '--clipboard-put-command',
        type=str,
        default="",
        help='A command that puts given text to clipboard. %%s will be replaced with the text. (Default uses `xclip`.',
    )

    parser.add_argument(
        '-s',
        '--save-history',
        default=False,
        action='store_true',
        help='Enable saving history. History is saved as plain text. (Disabled by default.)',
    )

    parser.add_argument(
        '-f',
        '--use-formatting',
        default=False,
        action='store_true',
        help='Use _italic_, *bold*, ~strikethrough~ formatting in messages. (Disabled by default.)',
    )

    parser.add_argument('-w', '--wrap-at', default='85%', help='Wrap messages at given column.')  # Debuging; TODO: ? make default=100?

    parser.add_argument(
        '--one-sided',
        default=False,
        action='store_true',
        help='Show messages aligned to one side in message list. (Disabled by default.)',
    )

    parser.add_argument(
        '--show-names',
        default=False,
        action='store_true',
        help='Show contact names even in message list even if it is one-to-one conversation. (Disabled by default.)',
    )

    parser.add_argument(
        '--group-contacts',
        default=False,
        action='store_true',
        help='Show groups and contacts seperately under the left pane. (Disabled by default)',
    )

    parser.add_argument(
        '--contacts-autohide',
        default=False,
        action='store_true',
        help='Autohide the contacts pane when it loses focus. (Disabled by default)',
    )

    parser.add_argument(
        '--contacts-sort-alpha',
        default=False,
        action='store_true',
        help='Sort contacts alphabetically. (Default: sort by the most recent message)',
    )

    parser.add_argument('--no-daemon', action='store_true', help='Not really useful.')

    parser.add_argument('--debug', default=False, action='store_true')

    cfg = parser.parse_args()
    file_cfg = parse_cfg_file(cfg.config_file)
    for key, val in file_cfg.items():
        attr = getattr(cfg, key)
        if isinstance(attr, bool):
            setattr(cfg, key, val.lower() in ['true', 't', 'yes', 'y'])
        elif isinstance(attr, int):
            setattr(cfg, key, int(val))
        else:
            setattr(cfg, key, val)

    return cfg


def main():
    cfg = parse_args()

    if not os.path.exists(SCLI_DATA_FOLDER):
        try:
            os.makedirs(SCLI_DATA_FOLDER)
        except OSError as exc:
            if not (exc.errno == errno.EEXIST and os.path.isdir(SCLI_DATA_FOLDER)):
                print("Can't create data directory.", file=sys.stderr)
                sys.exit(3)

    if cfg.debug:
        logging.basicConfig(filename=SCLI_LOG_FILE, level=logging.DEBUG, format='>>> %(funcName)s: %(message)s')
    else:
        logging.basicConfig(filename=SCLI_LOG_FILE, level=logging.CRITICAL)

    if not cfg.username:
        ulist = []
        for folder in [SIGNALCLI_DATA_FOLDER, SIGNALCLI_LEGACY_DATA_FOLDER]:
            try:
                users = [x for x in os.listdir(folder) if os.path.isfile(os.path.join(folder, x))]
                ulist.extend(users)
            except FileNotFoundError:
                pass

        if not ulist:
            print("Couldn't find any linked device.", file=sys.stderr)
            sys.exit(1)
        elif len(ulist) == 1:
            cfg.username = ulist[0]
        else:
            print("Use one of these:", file=sys.stderr)
            for u in ulist:
                print("\tscli --username=" + u, file=sys.stderr)
            sys.exit(1)

    state = State(ObservableConfig(cfg))
    window = MainWindow(state)

    loop = urwid.MainLoop(window, palette=PALETTE)
    state.commands._urwid_loop = state.daemon._urwid_loop = loop

    if not cfg.no_daemon:
        proc = state.daemon.start(cfg.username)
        atexit.register(proc.kill)

    if cfg.debug:
        _measure_startup_time(loop)

    MessageWidgetsCache.OWN_NUM = cfg.username

    msg_ws_cache = window._wchat.msgs_list.body.msg_ws_cache
    urwid.connect_signal(state.delivery_status, 'delivery_status_changed', msg_ws_cache.on_delivery_status_changed)
    msg_ws_cache.set_delivery_status_query_func(state.delivery_status.get_str)

    urwid.connect_signal(state.daemon, 'send_message', state.delivery_status.on_send_message)
    urwid.connect_signal(state.daemon, 'sending_done', state.delivery_status.on_sending_done)
    urwid.connect_signal(state.daemon, 'receive_receipt', state.delivery_status.on_receive_receipt)

    urwid.connect_signal(state.daemon, 'receive_message', state.on_receive_message)
    urwid.connect_signal(state.daemon, 'send_message', state.on_send_message)
    urwid.connect_signal(state.daemon, 'sending_done', state.on_sending_done)

    loop.run()


if __name__ == "__main__":
    main()
